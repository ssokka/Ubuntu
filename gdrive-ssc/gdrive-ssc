#!/usr/bin/env bash

############################################################
usage() {
cat << EOF

사용법: bash $0 SOURCE TARGET TASK_NAME COMMAND

버전: 2020.08.28.04

동일한 작업은 이전 작업 이름으로 설정해야 작업 시간을 절약할 수 있습니다.

필수 설치 gclone
          https://github.com/wiserain/gclone/releases

SOURCE    필수
          source:folder
          source: SOURCE 섹션 이름, 필수
          folder  하위 폴더 이름, 선택

TARGET    필수
          target:folder
          target: TARGET 섹션 이름, 필수
          folder  하위 폴더 이름, 선택

TASK_NAME 작업 이름, 필수

COMMAND   명령, 필수
          * 스크립트 기능

          all         * 전체 실행
                        아래 순서대로 실행됩니다.

          copy          복사
                        기본 옵션  --drive-server-side-across-configs
                        활용 옵션  --exclude-from target-lsf.log

          dedupe        TARGET dedupe newest
                        기본 옵션  --drive-use-trash=false
                        활용 옵션  target-deup-dir.log

          lsf           파일 목록
                        SOURCE     결과 파일이 존재할 경우 15분 후 실행
                        TARGET     SOURCE 파일 목록과 같지 않을 경우 실행
                        자동 실행  dupe, dupe-dir

          lsf-count   * 파일 목록 개수
                        자동 실행  dupe, dupe-dir

          dupe        * 중복 파일 목록
                        자동 실행  dupe-dir

          dupe-dir    * 중복 파일의 상위 폴더 목록

          old         * SOURCE에는 없고 TARGET에만 있는 파일 목록

          old-delete  * TARGET의 old 파일 목록 삭제
                        기본 옵션  --drive-use-trash=false

          miss        * SOURCE에는 있고 TARGET에는 없는 파일 목록

          miss-copy   * TARGET의 miss 파일 목록 복사
                        기본 옵션  --drive-server-side-across-configs

          size         파일 개수 및 파일 크기

          rmdirs      * TARGET의 빈 폴더 삭제
                        기본 옵션  --drive-use-trash=false
                        all 명령에서 제외

로그
     폴더   $basedir/TASK_NAME
     결과   [SOURCE|TARGET]-COMMAND.log
     개수   count-all.log
     크기   count-size.log
     작업   task.log
     clone  clone.log

EOF
}

############################################################
# set basedir
############################################################
oIFS=$IFS;
basedir="`pwd`/$0-task"

############################################################
# script commands
############################################################
source=$1
target=$2
tname=$3
command=$4
if [[ $# != 4 ]] || [[ "$source" != *":"* ]] || [[ "$target" != *":"* ]] ; then
	usage; exit 1
fi
case $command in
	all|lsf|lsf-count|dupe|dupe-dir|copy|dedupe|old|old-delete|miss|miss-copy|rmdirs|rsize|gsize);;
	*) usage; exit 1;;
esac

############################################################
# common functions
############################################################
timestamp(){
	echo `date "+%Y/%m/%d %H:%M:%S"`
}

runtime() {
	# $1: start time
	# $2: end time
	# $3: minute
	local diff=$((`date -d "$2" +%s`-`date -d "$1" +%s`))
	if [[ $diff -lt 0 ]]; then
		echo "0d 0h 0m 0s"
	else
		if [[ $3 == m ]]; then
			echo $(($diff/60))
		else
			echo "$(($diff/86400))d $((($diff/3600)%24))h $((($diff/60)%60))m $(($diff%60))s"
		fi
	fi
}

echo_color() {
	# $1: color name
	# $2: string
	# $n: color number
	case $1 in
		r) n=31;; # red
		g) n=32;; # green
		y) n=33;; # yellow
		b) n=34;; # blue
		*) n=39;; # white
	esac
	if [[ ! -f /.dockerenv ]]; then
		echo -e "\e[0;${n}m${2}\e[0m"
	else
		echo -e "$2"
	fi
}

log_msg=""
log_fmt() {
	local color="$1" type="$2" msg="$3"
	log_msg="`timestamp` `printf "%-5s" "$type"` : $msg"
	echo_color $color "$log_msg"
	echo -e "$log_msg" >> "$tlog"
	if [[ $type == COUNT ]]; then
		sed -i "1i$log_msg" "$calog"
	fi
	if [[ $type == ERROR ]]; then
		echo; exit 1
	fi
}

make_dir() {
	if [[ ! -d $1 ]]; then
		mkdir -p "$1"
	fi
}

check_path() {
	local path=$1 file=`printf "%-11s" "$2"`
	IFS=';'
	for item in $path; do
		if [[ -f $item ]]; then
			eval $3="$item"
			log_fmt w INFO "path | $file | $item"
			return 0
		fi
	done
	IFS=$oIFS
	log_fmt r ERROR "path | $file | Not found"
}

############################################################
# get path
############################################################
get_path() {
	local file path
	########################################################
	file="rclone"; unset path
	########################################################
	if [[ ! -f /.dockerenv ]]; then
		path+="/usr/bi n/$file;"
		path+="/usr/bin/$file;"
	else
		case `uname` in
			Linux)
				case `uname -m` in
					x86_64|i686|386)
						path+="/app/bin/$file;";;
					aarch64|arm)
						path+="/app/bin/LinuxArm/$file;";;
				esac	
				;;
			Darwin)
				path+="/app/bin/Darwin/$file;";;
		esac
	fi
	# check_path "$path" "$file" "rclone"
	########################################################
	file="rclone.conf"; unset path
	########################################################
	if [[ ! -f /.dockerenv ]]; then
		path+="$HOME/$file;"
		path+="$HOME/.config/$file;"
		path+="$HOME/.config/rclone/$file;"
		path+="$HOME/.config/gclone/$file;"
	else
		path+="/app/data/db/$file;"
	fi
	# check_path "$path" "$file" "rconf"
	########################################################
	file="gclone"; unset path
	########################################################
	if [[ ! -f /.dockerenv ]]; then
		path+="/usr/bin/$file;"
		path+="/opt/sjva/custom/rclone_expand/bin/$file;"
	else
		path+="/app/data/custom/rclone_expand/bin/$file;"
	fi
	check_path "$path" "$file" "gclone"
	########################################################
	file="gclone.conf"; unset path
	########################################################
	if [[ ! -f /.dockerenv ]]; then
		path+="$HOME/$file;"
		path+="$HOME/.config/$file;"
		path+="$HOME/.config/gclone/$file;"
		path+="$HOME/.config/rclone/$file;"
		path+="/opt/sjva/custom/rclone_expand/$file;"
	else
		path+="/app/data/rclone_expand/$file;"
	fi
	check_path "$path" "$file" "gconf"
	########################################################
}

check_file() {
	case $# in
		1)
			if [[ -f $1 ]] && [[ `sed '/^$/d' "$1" | wc -l` != 0 ]]; then
				echo 0
			else
				echo 1
			fi
		;;
		2)
			if [[ -f $1 ]] && [[ `sed '/^$/d' "$1" | wc -l` != 0 ]] && [[ -f $2 ]] && [[ `sed '/^$/d' "$2" | wc -l` != 0 ]]; then
				echo 0
			else
				echo 1
			fi
		;;
	esac
}

############################################################
# clone
############################################################
clone() {
	# $1: path
	# $2: task
	# $3: log on/off
	local path="$1" task="$2" loff="$3"
	
	# $tlmt: --transfers, -tpslimit, --tpslimit-burst
	local tlmt=5
	
	local path_ori path_str
	if [[ -z $pmax ]]; then
		pmax=$((${#source}>${#target}?${#source}:${#target}))
	fi
	case $path in
	source)
		path_ori="$source"
		path_str="source | `printf "%-${pmax}s" $path_ori`"
	;;
	target)
		path_ori="$target"
		path_str="target | `printf "%-${pmax}s" $path_ori`"
	;;
	server)
		path_str="source | `printf "%-${pmax}s" $source` | target | `printf "%-${pmax}s" $target`"
	;;
	esac
	
	rm -f "$clog"
	local opt_cm="--disable ListR --fast-list --no-traverse --tpslimit $tlmt --tpslimit-burst $tlmt --log-level INFO --log-file="$clog""
	local opt_cp="--ignore-existing --progress --size-only --stats 1s --transfers $tlmt $opt_cm"
	local opt_sv="--drive-server-side-across-configs $opt_cp"
	
	local log cmd data
	local slsf="$tdir/source-lsf.log"
	local tlsf="$tdir/target-lsf.log"
	
	if [[ -z $tmax ]]; then
		mstr="old-delete"
		tmax=${#mstr}
	fi
	
	############################################################
	# command
	############################################################
	case $task in
	copy)
		log="$clog"
		data="$tdir/target-lsf.log"
		if [[ `check_file "$data"` == 1 ]]; then
			clone target lsf
		fi
		local exclude
		if [[ `check_file "$tlsf"` == 0 ]]; then
			#exclude=" --exclude-from \"$tlsf\""
			local etmp="$temp/target-lsf-exclude.log"
			cat "$tlsf" | sed -e 's/\[/\\\[/g' -e 's/\]/\\\]/g' > "$etmp"
			exclude=" --exclude-from \"$etmp\""
		else
			exclude=""
		fi
		cmd+=("$gclone copy \"$source\" \"$target\"${exclude} $opt_sv")
	;;
	dedupe) # dedupe not support --include-from
		log="$tdir/$path-$task-dir.log"
		data="$tdir/$path-dupe-dir.log"
		if [[ `check_file "$data"` == 1 ]]; then
			clone $path dupe-dir 0
		fi
		if [[ `check_file "$data"` == 0 ]]; then
			for item in `cat "$data"`; do
				cmd+=("$gclone dedupe \"${path_ori}${item}\" --dedupe-mode newest --drive-use-trash=false $opt_cm")
			done
		fi
	;;
	lsf)
		log="$tdir/$path-$task.log"
		local run=1
		case $path in
		source)
			if [[ `check_file "$slsf"` == 0 ]] && [[ $(runtime `date -r "$slsf"` `date` m) -gt 15 ]]; then
				log="$slsf"
				run=0
			fi
		;;
		target)
			if [[ `check_file "$slsf" "$tlsf"` == 0 ]]; then
				sort -o "$slsf" "$slsf"
				sort -o "$tlsf" "$tlsf"
				if `cmp -s "$slsf" "$tlsf"`; then
					log="$tlsf"
					run=0
				fi
			fi
		;;
		esac
		if [[ $run == 1 ]]; then
			# cmd+=("$rclone lsf \"$path_ori\" -R --format psti --files-only $opt_cm | sort > \"$log\"") # detail lsf
			cmd+=("$rclone lsf \"$path_ori\" -R --files-only $opt_cm | sort > \"$log\"")
		fi
	;;
	lsf-count)
		log="$tdir/$path-lsf.log"
		if [[ `check_file "$log"` == 1 ]]; then
			clone $path lsf
		fi
	;;
	dupe)
		log="$tdir/$path-$task.log"
		data="$tdir/$path-lsf.log"
		if [[ `check_file "$data"` == 1 ]]; then
			clone $path lsf-count 0
		fi
		if [[ `check_file "$data"` == 0 ]]; then
			cmd+=("cat \"$data\" | uniq -d > \"$log\"")
		fi
	;;
	dupe-dir)
		log="$tdir/$path-$task.log"
		data="$tdir/$path-dupe.log"
		if [[ `check_file "$data"` == 1 ]]; then
			clone $path dupe 0
		fi
		if [[ `check_file "$data"` == 0 ]]; then
			cmd+=("cat \"$data\" | xargs dirname | uniq -u > \"$log\"")
		fi
	;;
	old)
		log="$tdir/$path-$task.log"
		if [[ `check_file "$slsf"` == 1 ]]; then
			clone source lsf 0
		fi
		if [[ `check_file "$tlsf"` == 1 ]]; then
			clone target lsf 0
		fi
		if [[ `check_file "$slsf" "$tlsf"` == 0 ]]; then
			cmd+=("comm -13 <(sort \"$slsf\") <(sort \"$tlsf\") > \"$log\"")
		fi
	;;
	old-delete)
		log="$clog"
		data="$tdir/target-old.log"
		if [[ `check_file "$data"` == 1 ]]; then
			clone target old
		fi
		if [[ `check_file "$data"` == 0 ]]; then
			cmd+=("$rclone delete \"$path_ori\" --files-from \"$data\" --drive-use-trash=false $opt_cm")
		fi
	;;
	miss)
		log="$tdir/$path-$task.log"
		if [[ `check_file "$slsf"` == 1 ]]; then
			clone source lsf
		fi
		if [[ `check_file "$tlsf"` == 1 ]]; then
			clone target lsf
		fi
		if [[ `check_file "$slsf" "$tlsf"` == 0 ]]; then
			cmd+=("comm -13 <(sort \"$tlsf\") <(sort \"$slsf\") > \"$log\"")
		fi
	;;
	miss-copy)
		log="$clog"
		data="$tdir/$path-miss.log"
		if [[ `check_file "$data"` == 1 ]]; then
			clone target miss 1
		fi
		if [[ `check_file "$data"` == 0 ]]; then
			cmd+=("$gclone copy \"$source\" \"$target\" --files-from \"$data\" $opt_sv")
		fi
	;;
	rmdirs)
		log="$clog"
		cmd+=("$gclone rmdirs \"$path_ori\" --leave-root --drive-use-trash=false $opt_cm")
	;;
	size)
		log="$clog"
		cmd+=("$gclone size \"$path_ori\" --size-only $opt_cm > \"$log\"")
	;;
	esac
	
	############################################################
	# run
	############################################################
	if [[ ${#cmd[@]} != 0 ]]; then
		local stime=`date`
		for item in "${cmd[@]}"; do
			if [[ $loff != 0 ]]; then
				log_fmt w TASK "$path_str | `printf "%-${tmax}s" $task` | $item"
			fi
			eval "$item"
			if [[ $? != 0 ]]; then
				if [[ -f $clog ]]; then
					item="\n$clog"
				fi
				log_fmt r ERROR "$item"
			fi
		done
		local etime=`date`
	fi
	
	############################################################
	# count
	############################################################
	local count=0
	if [[ -f $log ]]; then
		case $task in
			size|lsf) sed -i "/^gclone.*\?json$/d" "$log";; # clean
		esac
		case $task in
			copy|miss-copy|old-delete|rmdirs)
				local cstr
				case $task in 
					copy|miss-copy) cstr="Copied";;
					dedupe|old-delete) cstr="Deleted";;
					rmdirs) cstr="Removing directory";;
				esac
				clst=`cat "$log" | grep "$cstr"`
				count=`echo "$clst" | wc -l`
				# echo "$clst" | tee -a "$tlog"
				tail -n $tlmt "$clst" |  tee -a "$tlog"
				# update target-lsf.log
				case $task in 
					copy|miss-copy)
						echo "$clst" | cut -d ':' -f 4 | sed -e '/^\s/d' -e '/\s$/d' >> "$tlsf"
					;;
					dedupe|old-delete)
						IFS=$'\n'
						for item in $cstr; do
							sed -i "/$item/d" "$tlsf"
						done
						IFS=$oIFS
					;;
				esac
				sort -o "$tlsf" "$tlsf"
				# log_fmt g INFO "$path_str | $cstr | $count | $tlsf"
			;;
			size)
				count=`sed -z 's/\n/ | /' "$log" | sed -e '/^\s/d' -e '/\s$/d' -e 's/\s\{1,\}/ /g'`
			;;
			*)
				count=`sed '/^$/d' "$log" | wc -l`
				if [[ $count == 0 ]] && [[ "$log" != "$clog" ]]; then
					rm -f "$log"
				fi
			;;
		esac
	fi
	if [[ $loff != 1 ]]; then
		log_fmt g COUNT "$path_str | `printf "%-${tmax}s" $task` | $count | `runtime $stime $etime`"
		case $task in
			size) sed -i "1i$log_msg" "$cslog";;
		esac
	fi
}

############################################################

title="Google Drive Server Side Clone"

tdir="$basedir/$tname"
temp="$tdir/temp"
make_dir "$tdir/temp"

tlog="$tdir/task.log"
clog="$tdir/clone.log"

calog="$tdir/count-all.log"
if [[ ! -f $calog ]]; then
	echo > "$calog"
fi
cslog="$tdir/count-size.log"
if [[ ! -f $cslog ]]; then
	echo > "$cslog"
fi

echo
log_fmt y START "========== ${title} =========="
log_fmt y INFO "args      | `echo $@`"
log_fmt y INFO "source    | $1"
log_fmt y INFO "target    | $2"
log_fmt y INFO "task name | $3"
log_fmt y INFO "command   | $4"

log_fmt w INFO "path | `printf "%-11s" task` | $tdir"
get_path

# rclone="$rclone --config \"$rconf\""
gclone="$gclone --config \"$gconf\""

stime=`date`

case $command in
all)
	clone server copy
	clone target dedupe
	
	clone source lsf
	clone target lsf
	clone source dupe
	clone target dupe
	clone source dupe-dir
	clone target dupe-dir
	
	clone target old
	clone target old-delete
	
	clone target miss
	clone server miss-copy
	
	clone target lsf

	clone source lsf-count
	clone target lsf-count	
	
	clone source size
	clone target size
;;
lsf)
	clone source $command
	clone target $command
	clone source dupe
	clone target dupe
	clone source dupe-dir
	clone target dupe-dir
;;
lsf-count)
	clone source $command
	clone target $command
	clone source dupe
	clone target dupe
	clone source dupe-dir
	clone target dupe-dir
;;
dupe)
	clone source $command
	clone target $command
	clone source dupe-dir
	clone target dupe-dir
;;
dupe-dir|size)
	clone source $command
	clone target $command
;;
copy|miss-copy)
	clone server $command
;;
dedupe|old|old-delete|miss|rmdirs)
	clone target $command
;;
*) usage; exit 1;;
esac

etime=`date`
log_fmt y INFO "runtime | `runtime $stime $etime`"
log_fmt y END "========== ${title} =========="
echo
